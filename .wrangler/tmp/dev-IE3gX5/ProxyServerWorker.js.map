{
  "version": 3,
  "sources": ["../../../../../.nvm/versions/node/v23.11.1/lib/node_modules/wrangler/wrangler-dist/ProxyServerWorker.js", "../../../../../.nvm/versions/node/v23.11.1/lib/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../bundle-qpqDPe/middleware-insertion-facade.js", "../../../../../.nvm/versions/node/v23.11.1/lib/node_modules/wrangler/templates/middleware/common.ts", "../bundle-qpqDPe/middleware-loader.entry.ts"],
  "sourceRoot": "/home/yanggf/a/cct/.wrangler/tmp/dev-IE3gX5",
  "sourcesContent": ["// ../../node_modules/.pnpm/capnweb@0.1.0/node_modules/capnweb/dist/index.js\nif (!Symbol.dispose) {\n  Symbol.dispose = Symbol.for(\"dispose\");\n}\nif (!Symbol.asyncDispose) {\n  Symbol.asyncDispose = Symbol.for(\"asyncDispose\");\n}\nvar workersModuleName = navigator.userAgent === \"Cloudflare-Workers\" ? \"cloudflare:workers\" : null;\nvar workersModule;\nif (workersModuleName) {\n  workersModule = await import(\n    /* @vite-ignore */\n    workersModuleName\n  );\n}\nvar RpcTarget = workersModule ? workersModule.RpcTarget : class {\n};\nfunction typeForRpc(value) {\n  switch (typeof value) {\n    case \"boolean\":\n    case \"number\":\n    case \"string\":\n      return \"primitive\";\n    case \"undefined\":\n      return \"undefined\";\n    case \"object\":\n    case \"function\":\n      break;\n    case \"bigint\":\n      return \"bigint\";\n    default:\n      return \"unsupported\";\n  }\n  if (value === null) {\n    return \"primitive\";\n  }\n  let prototype = Object.getPrototypeOf(value);\n  switch (prototype) {\n    case Object.prototype:\n      return \"object\";\n    case Function.prototype:\n      return \"function\";\n    case Array.prototype:\n      return \"array\";\n    case Date.prototype:\n      return \"date\";\n    case Uint8Array.prototype:\n      return \"bytes\";\n    // TODO: All other structured clone types.\n    case RpcStub.prototype:\n      return \"stub\";\n    case RpcPromise.prototype:\n      return \"rpc-promise\";\n    // TODO: Promise<T> or thenable\n    default:\n      if (workersModule) {\n        if (prototype == workersModule.RpcStub.prototype || value instanceof workersModule.ServiceStub) {\n          return \"rpc-target\";\n        } else if (prototype == workersModule.RpcPromise.prototype || prototype == workersModule.RpcProperty.prototype) {\n          return \"rpc-thenable\";\n        }\n      }\n      if (value instanceof RpcTarget) {\n        return \"rpc-target\";\n      }\n      if (value instanceof Error) {\n        return \"error\";\n      }\n      return \"unsupported\";\n  }\n}\nfunction mapNotLoaded() {\n  throw new Error(\"RPC map() implementation was not loaded.\");\n}\nvar mapImpl = { applyMap: mapNotLoaded, sendMap: mapNotLoaded };\nvar StubHook = class {\n};\nvar ErrorStubHook = class extends StubHook {\n  constructor(error) {\n    super();\n    this.error = error;\n  }\n  call(path, args) {\n    return this;\n  }\n  map(path, captures, instructions) {\n    return this;\n  }\n  get(path) {\n    return this;\n  }\n  dup() {\n    return this;\n  }\n  pull() {\n    return Promise.reject(this.error);\n  }\n  ignoreUnhandledRejections() {\n  }\n  dispose() {\n  }\n  onBroken(callback) {\n    try {\n      callback(this.error);\n    } catch (err) {\n      Promise.resolve(err);\n    }\n  }\n};\nvar DISPOSED_HOOK = new ErrorStubHook(\n  new Error(\"Attempted to use RPC stub after it has been disposed.\")\n);\nvar doCall = (hook, path, params) => {\n  return hook.call(path, params);\n};\nfunction withCallInterceptor(interceptor, callback) {\n  let oldValue = doCall;\n  doCall = interceptor;\n  try {\n    return callback();\n  } finally {\n    doCall = oldValue;\n  }\n}\nvar RAW_STUB = Symbol(\"realStub\");\nvar PROXY_HANDLERS = {\n  apply(target, thisArg, argumentsList) {\n    let stub = target.raw;\n    return new RpcPromise(doCall(\n      stub.hook,\n      stub.pathIfPromise || [],\n      RpcPayload.fromAppParams(argumentsList)\n    ), []);\n  },\n  get(target, prop, receiver) {\n    let stub = target.raw;\n    if (prop === RAW_STUB) {\n      return stub;\n    } else if (prop in RpcPromise.prototype) {\n      return stub[prop];\n    } else if (typeof prop === \"string\") {\n      return new RpcPromise(\n        stub.hook,\n        stub.pathIfPromise ? [...stub.pathIfPromise, prop] : [prop]\n      );\n    } else if (prop === Symbol.dispose && (!stub.pathIfPromise || stub.pathIfPromise.length == 0)) {\n      return () => {\n        stub.hook.dispose();\n        stub.hook = DISPOSED_HOOK;\n      };\n    } else {\n      return void 0;\n    }\n  },\n  has(target, prop) {\n    let stub = target.raw;\n    if (prop === RAW_STUB) {\n      return true;\n    } else if (prop in RpcPromise.prototype) {\n      return prop in stub;\n    } else if (typeof prop === \"string\") {\n      return true;\n    } else if (prop === Symbol.dispose && (!stub.pathIfPromise || stub.pathIfPromise.length == 0)) {\n      return true;\n    } else {\n      return false;\n    }\n  },\n  construct(target, args) {\n    throw new Error(\"An RPC stub cannot be used as a constructor.\");\n  },\n  defineProperty(target, property, attributes) {\n    throw new Error(\"Can't define properties on RPC stubs.\");\n  },\n  deleteProperty(target, p) {\n    throw new Error(\"Can't delete properties on RPC stubs.\");\n  },\n  getOwnPropertyDescriptor(target, p) {\n    return void 0;\n  },\n  getPrototypeOf(target) {\n    return Object.getPrototypeOf(target.raw);\n  },\n  isExtensible(target) {\n    return false;\n  },\n  ownKeys(target) {\n    return [];\n  },\n  preventExtensions(target) {\n    return true;\n  },\n  set(target, p, newValue, receiver) {\n    throw new Error(\"Can't assign properties on RPC stubs.\");\n  },\n  setPrototypeOf(target, v) {\n    throw new Error(\"Can't override prototype of RPC stubs.\");\n  }\n};\nvar RpcStub = class _RpcStub extends RpcTarget {\n  // Although `hook` and `path` are declared `public` here, they are effectively hidden by the\n  // proxy.\n  constructor(hook, pathIfPromise) {\n    super();\n    if (!(hook instanceof StubHook)) {\n      let value = hook;\n      if (value instanceof RpcTarget || value instanceof Function) {\n        hook = TargetStubHook.create(value, void 0);\n      } else {\n        hook = new PayloadStubHook(RpcPayload.fromAppReturn(value));\n      }\n      if (pathIfPromise) {\n        throw new TypeError(\"RpcStub constructor expected one argument, received two.\");\n      }\n    }\n    this.hook = hook;\n    this.pathIfPromise = pathIfPromise;\n    let func = () => {\n    };\n    func.raw = this;\n    return new Proxy(func, PROXY_HANDLERS);\n  }\n  hook;\n  pathIfPromise;\n  dup() {\n    let target = this[RAW_STUB];\n    if (target.pathIfPromise) {\n      return new _RpcStub(target.hook.get(target.pathIfPromise));\n    } else {\n      return new _RpcStub(target.hook.dup());\n    }\n  }\n  onRpcBroken(callback) {\n    this[RAW_STUB].hook.onBroken(callback);\n  }\n  map(func) {\n    let { hook, pathIfPromise } = this[RAW_STUB];\n    return mapImpl.sendMap(hook, pathIfPromise || [], func);\n  }\n};\nvar RpcPromise = class extends RpcStub {\n  // TODO: Support passing target value or promise to constructor.\n  constructor(hook, pathIfPromise) {\n    super(hook, pathIfPromise);\n  }\n  then(onfulfilled, onrejected) {\n    return pullPromise(this).then(...arguments);\n  }\n  catch(onrejected) {\n    return pullPromise(this).catch(...arguments);\n  }\n  finally(onfinally) {\n    return pullPromise(this).finally(...arguments);\n  }\n};\nfunction unwrapStubTakingOwnership(stub) {\n  let { hook, pathIfPromise } = stub[RAW_STUB];\n  if (pathIfPromise && pathIfPromise.length > 0) {\n    return hook.get(pathIfPromise);\n  } else {\n    return hook;\n  }\n}\nfunction unwrapStubAndDup(stub) {\n  let { hook, pathIfPromise } = stub[RAW_STUB];\n  if (pathIfPromise) {\n    return hook.get(pathIfPromise);\n  } else {\n    return hook.dup();\n  }\n}\nfunction unwrapStubNoProperties(stub) {\n  let { hook, pathIfPromise } = stub[RAW_STUB];\n  if (pathIfPromise && pathIfPromise.length > 0) {\n    return void 0;\n  }\n  return hook;\n}\nfunction unwrapStubOrParent(stub) {\n  return stub[RAW_STUB].hook;\n}\nfunction unwrapStubAndPath(stub) {\n  return stub[RAW_STUB];\n}\nasync function pullPromise(promise) {\n  let { hook, pathIfPromise } = promise[RAW_STUB];\n  if (pathIfPromise.length > 0) {\n    hook = hook.get(pathIfPromise);\n  }\n  let payload = await hook.pull();\n  return payload.deliverResolve();\n}\nvar RpcPayload = class _RpcPayload {\n  // Private constructor; use factory functions above to construct.\n  constructor(value, source, stubs, promises) {\n    this.value = value;\n    this.source = source;\n    this.stubs = stubs;\n    this.promises = promises;\n  }\n  // Create a payload from a value passed as params to an RPC from the app.\n  //\n  // The payload does NOT take ownership of any stubs in `value`, and but promises not to modify\n  // `value`. If the payload is delivered locally, `value` will be deep-copied first, so as not\n  // to have the sender and recipient end up sharing the same mutable object. `value` will not be\n  // touched again after the call returns synchronously (returns a promise) -- by that point,\n  // the value has either been copied or serialized to the wire.\n  static fromAppParams(value) {\n    return new _RpcPayload(value, \"params\");\n  }\n  // Create a payload from a value return from an RPC implementation by the app.\n  //\n  // Unlike fromAppParams(), in this case the payload takes ownership of all stubs in `value`, and\n  // may hold onto `value` for an arbitarily long time (e.g. to serve pipelined requests). It\n  // will still avoid modifying `value` and will make a deep copy if it is delivered locally.\n  static fromAppReturn(value) {\n    return new _RpcPayload(value, \"return\");\n  }\n  // Combine an array of payloads into a single payload whose value is an array. Ownership of all\n  // stubs is transferred from the inputs to the outputs, hence if the output is disposed, the\n  // inputs should not be. (In case of exception, nothing is disposed, though.)\n  static fromArray(array) {\n    let stubs = [];\n    let promises = [];\n    let resultArray = [];\n    for (let payload of array) {\n      payload.ensureDeepCopied();\n      for (let stub of payload.stubs) {\n        stubs.push(stub);\n      }\n      for (let promise of payload.promises) {\n        if (promise.parent === payload) {\n          promise = {\n            parent: resultArray,\n            property: resultArray.length,\n            promise: promise.promise\n          };\n        }\n        promises.push(promise);\n      }\n      resultArray.push(payload.value);\n    }\n    return new _RpcPayload(resultArray, \"owned\", stubs, promises);\n  }\n  // Create a payload from a value parsed off the wire using Evaluator.evaluate().\n  //\n  // A payload is constructed with a null value and the given stubs and promises arrays. The value\n  // is expected to be filled in by the evaluator, and the stubs and promises arrays are expected\n  // to be extended with stubs found during parsing. (This weird usage model is necessary so that\n  // if the root value turns out to be a promise, its `parent` in `promises` can be the payload\n  // object itself.)\n  //\n  // When done, the payload takes ownership of the final value and all the stubs within. It may\n  // modify the value in preparation for delivery, and may deliver the value directly to the app\n  // without copying.\n  static forEvaluate(stubs, promises) {\n    return new _RpcPayload(null, \"owned\", stubs, promises);\n  }\n  // Deep-copy the given value, including dup()ing all stubs.\n  //\n  // If `value` is a function, it should be bound to `oldParent` as its `this`.\n  //\n  // If deep-copying from a branch of some other RpcPayload, it must be provided, to make sure\n  // RpcTargets found within don't get duplicate stubs.\n  static deepCopyFrom(value, oldParent, owner) {\n    let result = new _RpcPayload(null, \"owned\", [], []);\n    result.value = result.deepCopy(\n      value,\n      oldParent,\n      \"value\",\n      result,\n      /*dupStubs=*/\n      true,\n      owner\n    );\n    return result;\n  }\n  // For `soruce === \"return\"` payloads only, this tracks any StubHooks created around RpcTargets\n  // found in the payload at the time that it is serialized (or deep-copied) for return, so that we\n  // can make sure they are not disposed before the pipeline ends.\n  //\n  // This is initialized on first use.\n  rpcTargets;\n  // Get the StubHook representing the given RpcTarget found inside this payload.\n  getHookForRpcTarget(target, parent, dupStubs = true) {\n    if (this.source === \"params\") {\n      return TargetStubHook.create(target, parent);\n    } else if (this.source === \"return\") {\n      let hook = this.rpcTargets?.get(target);\n      if (hook) {\n        if (dupStubs) {\n          return hook.dup();\n        } else {\n          this.rpcTargets?.delete(target);\n          return hook;\n        }\n      } else {\n        hook = TargetStubHook.create(target, parent);\n        if (dupStubs) {\n          if (!this.rpcTargets) {\n            this.rpcTargets = /* @__PURE__ */ new Map();\n          }\n          this.rpcTargets.set(target, hook);\n          return hook.dup();\n        } else {\n          return hook;\n        }\n      }\n    } else {\n      throw new Error(\"owned payload shouldn't contain raw RpcTargets\");\n    }\n  }\n  deepCopy(value, oldParent, property, parent, dupStubs, owner) {\n    let kind = typeForRpc(value);\n    switch (kind) {\n      case \"unsupported\":\n        return value;\n      case \"primitive\":\n      case \"bigint\":\n      case \"date\":\n      case \"bytes\":\n      case \"error\":\n      case \"undefined\":\n        return value;\n      case \"array\": {\n        let array = value;\n        let len = array.length;\n        let result = new Array(len);\n        for (let i = 0; i < len; i++) {\n          result[i] = this.deepCopy(array[i], array, i, result, dupStubs, owner);\n        }\n        return result;\n      }\n      case \"object\": {\n        let result = {};\n        let object = value;\n        for (let i in object) {\n          result[i] = this.deepCopy(object[i], object, i, result, dupStubs, owner);\n        }\n        return result;\n      }\n      case \"stub\":\n      case \"rpc-promise\": {\n        let stub = value;\n        let hook;\n        if (dupStubs) {\n          hook = unwrapStubAndDup(stub);\n        } else {\n          hook = unwrapStubTakingOwnership(stub);\n        }\n        if (stub instanceof RpcPromise) {\n          let promise = new RpcPromise(hook, []);\n          this.promises.push({ parent, property, promise });\n          return promise;\n        } else {\n          let newStub = new RpcStub(hook);\n          this.stubs.push(newStub);\n          return newStub;\n        }\n      }\n      case \"function\":\n      case \"rpc-target\": {\n        let target = value;\n        let stub;\n        if (owner) {\n          stub = new RpcStub(owner.getHookForRpcTarget(target, oldParent, dupStubs));\n        } else {\n          stub = new RpcStub(TargetStubHook.create(target, oldParent));\n        }\n        this.stubs.push(stub);\n        return stub;\n      }\n      case \"rpc-thenable\": {\n        let target = value;\n        let promise;\n        if (owner) {\n          promise = new RpcPromise(owner.getHookForRpcTarget(target, oldParent, dupStubs), []);\n        } else {\n          promise = new RpcPromise(TargetStubHook.create(target, oldParent), []);\n        }\n        this.promises.push({ parent, property, promise });\n        return promise;\n      }\n      default:\n        throw new Error(\"unreachable\");\n    }\n  }\n  // Ensures that if the value originally came from an unowned source, we have replaced it with a\n  // deep copy.\n  ensureDeepCopied() {\n    if (this.source !== \"owned\") {\n      let dupStubs = this.source === \"params\";\n      this.stubs = [];\n      this.promises = [];\n      try {\n        this.value = this.deepCopy(this.value, void 0, \"value\", this, dupStubs, this);\n      } catch (err) {\n        this.stubs = void 0;\n        this.promises = void 0;\n        throw err;\n      }\n      this.source = \"owned\";\n      if (this.rpcTargets && this.rpcTargets.size > 0) {\n        throw new Error(\"Not all rpcTargets were accounted for in deep-copy?\");\n      }\n      this.rpcTargets = void 0;\n    }\n  }\n  // Resolve all promises in this payload and then assign the final value into `parent[property]`.\n  deliverTo(parent, property, promises) {\n    this.ensureDeepCopied();\n    if (this.value instanceof RpcPromise) {\n      _RpcPayload.deliverRpcPromiseTo(this.value, parent, property, promises);\n    } else {\n      parent[property] = this.value;\n      for (let record of this.promises) {\n        _RpcPayload.deliverRpcPromiseTo(record.promise, record.parent, record.property, promises);\n      }\n    }\n  }\n  static deliverRpcPromiseTo(promise, parent, property, promises) {\n    let hook = unwrapStubNoProperties(promise);\n    if (!hook) {\n      throw new Error(\"property promises should have been resolved earlier\");\n    }\n    let inner = hook.pull();\n    if (inner instanceof _RpcPayload) {\n      inner.deliverTo(parent, property, promises);\n    } else {\n      promises.push(inner.then((payload) => {\n        let subPromises = [];\n        payload.deliverTo(parent, property, subPromises);\n        if (subPromises.length > 0) {\n          return Promise.all(subPromises);\n        }\n      }));\n    }\n  }\n  // Call the given function with the payload as an argument. The call is made synchronously if\n  // possible, in order to maintain e-order. However, if any RpcPromises exist in the payload,\n  // they are awaited and substituted before calling the function. The result of the call is\n  // wrapped into another payload.\n  //\n  // The payload is automatically disposed after the call completes. The caller should not call\n  // dispose().\n  async deliverCall(func, thisArg) {\n    try {\n      let promises = [];\n      this.deliverTo(this, \"value\", promises);\n      if (promises.length > 0) {\n        await Promise.all(promises);\n      }\n      let result = Function.prototype.apply.call(func, thisArg, this.value);\n      if (result instanceof RpcPromise) {\n        return _RpcPayload.fromAppReturn(result);\n      } else {\n        return _RpcPayload.fromAppReturn(await result);\n      }\n    } finally {\n      this.dispose();\n    }\n  }\n  // Produce a promise for this payload for return to the application. Any RpcPromises in the\n  // payload are awaited and substituted with their results first.\n  //\n  // The returned object will have a disposer which disposes the payload. The caller should not\n  // separately dispose it.\n  async deliverResolve() {\n    try {\n      let promises = [];\n      this.deliverTo(this, \"value\", promises);\n      if (promises.length > 0) {\n        await Promise.all(promises);\n      }\n      let result = this.value;\n      if (result instanceof Object) {\n        if (!(Symbol.dispose in result)) {\n          Object.defineProperty(result, Symbol.dispose, {\n            // NOTE: Using `this.dispose.bind(this)` here causes Playwright's build of\n            //   Chromium 140.0.7339.16 to fail when the object is assigned to a `using` variable,\n            //   with the error:\n            //       TypeError: Symbol(Symbol.dispose) is not a function\n            //   I cannot reproduce this problem in Chrome 140.0.7339.127 nor in Node or workerd,\n            //   so maybe it was a short-lived V8 bug or something. To be safe, though, we use\n            //   `() => this.dispose()`, which seems to always work.\n            value: () => this.dispose(),\n            writable: true,\n            enumerable: false,\n            configurable: true\n          });\n        }\n      }\n      return result;\n    } catch (err) {\n      this.dispose();\n      throw err;\n    }\n  }\n  dispose() {\n    if (this.source === \"owned\") {\n      this.stubs.forEach((stub) => stub[Symbol.dispose]());\n      this.promises.forEach((promise) => promise.promise[Symbol.dispose]());\n    } else if (this.source === \"return\") {\n      this.disposeImpl(this.value, void 0);\n      if (this.rpcTargets && this.rpcTargets.size > 0) {\n        throw new Error(\"Not all rpcTargets were accounted for in disposeImpl()?\");\n      }\n    } else ;\n    this.source = \"owned\";\n    this.stubs = [];\n    this.promises = [];\n  }\n  // Recursive dispose, called only when `source` is \"return\".\n  disposeImpl(value, parent) {\n    let kind = typeForRpc(value);\n    switch (kind) {\n      case \"unsupported\":\n      case \"primitive\":\n      case \"bigint\":\n      case \"bytes\":\n      case \"date\":\n      case \"error\":\n      case \"undefined\":\n        return;\n      case \"array\": {\n        let array = value;\n        let len = array.length;\n        for (let i = 0; i < len; i++) {\n          this.disposeImpl(array[i], array);\n        }\n        return;\n      }\n      case \"object\": {\n        let object = value;\n        for (let i in object) {\n          this.disposeImpl(object[i], object);\n        }\n        return;\n      }\n      case \"stub\":\n      case \"rpc-promise\": {\n        let stub = value;\n        let hook = unwrapStubNoProperties(stub);\n        if (hook) {\n          hook.dispose();\n        }\n        return;\n      }\n      case \"function\":\n      case \"rpc-target\": {\n        let target = value;\n        let hook = this.rpcTargets?.get(target);\n        if (hook) {\n          hook.dispose();\n          this.rpcTargets.delete(target);\n        } else {\n          disposeRpcTarget(target);\n        }\n        return;\n      }\n      case \"rpc-thenable\":\n        return;\n      default:\n        return;\n    }\n  }\n  // Ignore unhandled rejections in all promises in this payload -- that is, all promises that\n  // *would* be awaited if this payload were to be delivered. See the similarly-named method of\n  // StubHook for explanation.\n  ignoreUnhandledRejections() {\n    if (this.stubs) {\n      this.stubs.forEach((stub) => {\n        unwrapStubOrParent(stub).ignoreUnhandledRejections();\n      });\n      this.promises.forEach(\n        (promise) => unwrapStubOrParent(promise.promise).ignoreUnhandledRejections()\n      );\n    } else {\n      this.ignoreUnhandledRejectionsImpl(this.value);\n    }\n  }\n  ignoreUnhandledRejectionsImpl(value) {\n    let kind = typeForRpc(value);\n    switch (kind) {\n      case \"unsupported\":\n      case \"primitive\":\n      case \"bigint\":\n      case \"bytes\":\n      case \"date\":\n      case \"error\":\n      case \"undefined\":\n      case \"function\":\n      case \"rpc-target\":\n        return;\n      case \"array\": {\n        let array = value;\n        let len = array.length;\n        for (let i = 0; i < len; i++) {\n          this.ignoreUnhandledRejectionsImpl(array[i]);\n        }\n        return;\n      }\n      case \"object\": {\n        let object = value;\n        for (let i in object) {\n          this.ignoreUnhandledRejectionsImpl(object[i]);\n        }\n        return;\n      }\n      case \"stub\":\n      case \"rpc-promise\":\n        unwrapStubOrParent(value).ignoreUnhandledRejections();\n        return;\n      case \"rpc-thenable\":\n        value.then((_) => {\n        }, (_) => {\n        });\n        return;\n      default:\n        return;\n    }\n  }\n};\nfunction followPath(value, parent, path, owner) {\n  for (let i = 0; i < path.length; i++) {\n    parent = value;\n    let part = path[i];\n    if (part in Object.prototype) {\n      value = void 0;\n      continue;\n    }\n    let kind = typeForRpc(value);\n    switch (kind) {\n      case \"object\":\n      case \"function\":\n        if (Object.hasOwn(value, part)) {\n          value = value[part];\n        } else {\n          value = void 0;\n        }\n        break;\n      case \"array\":\n        if (Number.isInteger(part) && part >= 0) {\n          value = value[part];\n        } else {\n          value = void 0;\n        }\n        break;\n      case \"rpc-target\":\n      case \"rpc-thenable\": {\n        if (Object.hasOwn(value, part)) {\n          value = void 0;\n        } else {\n          value = value[part];\n        }\n        owner = null;\n        break;\n      }\n      case \"stub\":\n      case \"rpc-promise\": {\n        let { hook, pathIfPromise } = unwrapStubAndPath(value);\n        return { hook, remainingPath: pathIfPromise ? pathIfPromise.concat(path.slice(i)) : path.slice(i) };\n      }\n      case \"primitive\":\n      case \"bigint\":\n      case \"bytes\":\n      case \"date\":\n      case \"error\":\n        value = void 0;\n        break;\n      case \"undefined\":\n        value = value[part];\n        break;\n      case \"unsupported\": {\n        if (i === 0) {\n          throw new TypeError(`RPC stub points at a non-serializable type.`);\n        } else {\n          let prefix = path.slice(0, i).join(\".\");\n          let remainder = path.slice(0, i).join(\".\");\n          throw new TypeError(\n            `'${prefix}' is not a serializable type, so property ${remainder} cannot be accessed.`\n          );\n        }\n      }\n      default:\n        throw new TypeError(\"unreachable\");\n    }\n  }\n  if (value instanceof RpcPromise) {\n    let { hook, pathIfPromise } = unwrapStubAndPath(value);\n    return { hook, remainingPath: pathIfPromise || [] };\n  }\n  return {\n    value,\n    parent,\n    owner\n  };\n}\nvar ValueStubHook = class extends StubHook {\n  call(path, args) {\n    try {\n      let { value, owner } = this.getValue();\n      let followResult = followPath(value, void 0, path, owner);\n      if (followResult.hook) {\n        return followResult.hook.call(followResult.remainingPath, args);\n      }\n      if (typeof followResult.value != \"function\") {\n        throw new TypeError(`'${path.join(\".\")}' is not a function.`);\n      }\n      let promise = args.deliverCall(followResult.value, followResult.parent);\n      return new PromiseStubHook(promise.then((payload) => {\n        return new PayloadStubHook(payload);\n      }));\n    } catch (err) {\n      return new ErrorStubHook(err);\n    }\n  }\n  map(path, captures, instructions) {\n    try {\n      let followResult;\n      try {\n        let { value, owner } = this.getValue();\n        followResult = followPath(value, void 0, path, owner);\n        ;\n      } catch (err) {\n        for (let cap of captures) {\n          cap.dispose();\n        }\n        throw err;\n      }\n      if (followResult.hook) {\n        return followResult.hook.map(followResult.remainingPath, captures, instructions);\n      }\n      return mapImpl.applyMap(\n        followResult.value,\n        followResult.parent,\n        followResult.owner,\n        captures,\n        instructions\n      );\n    } catch (err) {\n      return new ErrorStubHook(err);\n    }\n  }\n  get(path) {\n    try {\n      let { value, owner } = this.getValue();\n      if (path.length === 0 && owner === null) {\n        throw new Error(\"Can't dup an RpcTarget stub as a promise.\");\n      }\n      let followResult = followPath(value, void 0, path, owner);\n      if (followResult.hook) {\n        return followResult.hook.get(followResult.remainingPath);\n      }\n      return new PayloadStubHook(RpcPayload.deepCopyFrom(\n        followResult.value,\n        followResult.parent,\n        followResult.owner\n      ));\n    } catch (err) {\n      return new ErrorStubHook(err);\n    }\n  }\n};\nvar PayloadStubHook = class _PayloadStubHook extends ValueStubHook {\n  constructor(payload) {\n    super();\n    this.payload = payload;\n  }\n  payload;\n  // cleared when disposed\n  getPayload() {\n    if (this.payload) {\n      return this.payload;\n    } else {\n      throw new Error(\"Attempted to use an RPC StubHook after it was disposed.\");\n    }\n  }\n  getValue() {\n    let payload = this.getPayload();\n    return { value: payload.value, owner: payload };\n  }\n  dup() {\n    let thisPayload = this.getPayload();\n    return new _PayloadStubHook(RpcPayload.deepCopyFrom(\n      thisPayload.value,\n      void 0,\n      thisPayload\n    ));\n  }\n  pull() {\n    return this.getPayload();\n  }\n  ignoreUnhandledRejections() {\n    if (this.payload) {\n      this.payload.ignoreUnhandledRejections();\n    }\n  }\n  dispose() {\n    if (this.payload) {\n      this.payload.dispose();\n      this.payload = void 0;\n    }\n  }\n  onBroken(callback) {\n    if (this.payload) {\n      if (this.payload.value instanceof RpcStub) {\n        this.payload.value.onRpcBroken(callback);\n      }\n    }\n  }\n};\nfunction disposeRpcTarget(target) {\n  if (Symbol.dispose in target) {\n    try {\n      target[Symbol.dispose]();\n    } catch (err) {\n      Promise.reject(err);\n    }\n  }\n}\nvar TargetStubHook = class _TargetStubHook extends ValueStubHook {\n  // Constructs a TargetStubHook that is not duplicated from an existing hook.\n  //\n  // If `value` is a function, `parent` is bound as its \"this\".\n  static create(value, parent) {\n    if (typeof value !== \"function\") {\n      parent = void 0;\n    }\n    return new _TargetStubHook(value, parent);\n  }\n  constructor(target, parent, dupFrom) {\n    super();\n    this.target = target;\n    this.parent = parent;\n    if (dupFrom) {\n      if (dupFrom.refcount) {\n        this.refcount = dupFrom.refcount;\n        ++this.refcount.count;\n      }\n    } else if (Symbol.dispose in target) {\n      this.refcount = { count: 1 };\n    }\n  }\n  target;\n  // cleared when disposed\n  parent;\n  // `this` parameter when calling `target`\n  refcount;\n  // undefined if not needed (because target has no disposer)\n  getTarget() {\n    if (this.target) {\n      return this.target;\n    } else {\n      throw new Error(\"Attempted to use an RPC StubHook after it was disposed.\");\n    }\n  }\n  getValue() {\n    return { value: this.getTarget(), owner: null };\n  }\n  dup() {\n    return new _TargetStubHook(this.getTarget(), this.parent, this);\n  }\n  pull() {\n    let target = this.getTarget();\n    if (\"then\" in target) {\n      return Promise.resolve(target).then((resolution) => {\n        return RpcPayload.fromAppReturn(resolution);\n      });\n    } else {\n      return Promise.reject(new Error(\"Tried to resolve a non-promise stub.\"));\n    }\n  }\n  ignoreUnhandledRejections() {\n  }\n  dispose() {\n    if (this.target) {\n      if (this.refcount) {\n        if (--this.refcount.count == 0) {\n          disposeRpcTarget(this.target);\n        }\n      }\n      this.target = void 0;\n    }\n  }\n  onBroken(callback) {\n  }\n};\nvar PromiseStubHook = class _PromiseStubHook extends StubHook {\n  promise;\n  resolution;\n  constructor(promise) {\n    super();\n    this.promise = promise.then((res) => {\n      this.resolution = res;\n      return res;\n    });\n  }\n  call(path, args) {\n    args.ensureDeepCopied();\n    return new _PromiseStubHook(this.promise.then((hook) => hook.call(path, args)));\n  }\n  map(path, captures, instructions) {\n    return new _PromiseStubHook(this.promise.then(\n      (hook) => hook.map(path, captures, instructions),\n      (err) => {\n        for (let cap of captures) {\n          cap.dispose();\n        }\n        throw err;\n      }\n    ));\n  }\n  get(path) {\n    return new _PromiseStubHook(this.promise.then((hook) => hook.get(path)));\n  }\n  dup() {\n    if (this.resolution) {\n      return this.resolution.dup();\n    } else {\n      return new _PromiseStubHook(this.promise.then((hook) => hook.dup()));\n    }\n  }\n  pull() {\n    if (this.resolution) {\n      return this.resolution.pull();\n    } else {\n      return this.promise.then((hook) => hook.pull());\n    }\n  }\n  ignoreUnhandledRejections() {\n    if (this.resolution) {\n      this.resolution.ignoreUnhandledRejections();\n    } else {\n      this.promise.then((res) => {\n        res.ignoreUnhandledRejections();\n      }, (err) => {\n      });\n    }\n  }\n  dispose() {\n    if (this.resolution) {\n      this.resolution.dispose();\n    } else {\n      this.promise.then((hook) => {\n        hook.dispose();\n      }, (err) => {\n      });\n    }\n  }\n  onBroken(callback) {\n    if (this.resolution) {\n      this.resolution.onBroken(callback);\n    } else {\n      this.promise.then((hook) => {\n        hook.onBroken(callback);\n      }, callback);\n    }\n  }\n};\nvar NullExporter = class {\n  exportStub(stub) {\n    throw new Error(\"Cannot serialize RPC stubs without an RPC session.\");\n  }\n  exportPromise(stub) {\n    throw new Error(\"Cannot serialize RPC stubs without an RPC session.\");\n  }\n  getImport(hook) {\n    return void 0;\n  }\n  unexport(ids) {\n  }\n  onSendError(error) {\n  }\n};\nvar NULL_EXPORTER = new NullExporter();\nvar ERROR_TYPES = {\n  Error,\n  EvalError,\n  RangeError,\n  ReferenceError,\n  SyntaxError,\n  TypeError,\n  URIError,\n  AggregateError\n  // TODO: DOMError? Others?\n};\nvar Devaluator = class _Devaluator {\n  constructor(exporter, source) {\n    this.exporter = exporter;\n    this.source = source;\n  }\n  // Devaluate the given value.\n  // * value: The value to devaluate.\n  // * parent: The value's parent object, which would be used as `this` if the value were called\n  //     as a function.\n  // * exporter: Callbacks to the RPC session for exporting capabilities found in this message.\n  // * source: The RpcPayload which contains the value, and therefore owns stubs within.\n  //\n  // Returns: The devaluated value, ready to be JSON-serialized.\n  static devaluate(value, parent, exporter = NULL_EXPORTER, source) {\n    let devaluator = new _Devaluator(exporter, source);\n    try {\n      return devaluator.devaluateImpl(value, parent, 0);\n    } catch (err) {\n      if (devaluator.exports) {\n        try {\n          exporter.unexport(devaluator.exports);\n        } catch (err2) {\n        }\n      }\n      throw err;\n    }\n  }\n  exports;\n  devaluateImpl(value, parent, depth) {\n    if (depth >= 64) {\n      throw new Error(\n        \"Serialization exceeded maximum allowed depth. (Does the message contain cycles?)\"\n      );\n    }\n    let kind = typeForRpc(value);\n    switch (kind) {\n      case \"unsupported\": {\n        let msg;\n        try {\n          msg = `Cannot serialize value: ${value}`;\n        } catch (err) {\n          msg = \"Cannot serialize value: (couldn't stringify value)\";\n        }\n        throw new TypeError(msg);\n      }\n      case \"primitive\":\n        return value;\n      case \"object\": {\n        let object = value;\n        let result = {};\n        for (let key in object) {\n          result[key] = this.devaluateImpl(object[key], object, depth + 1);\n        }\n        return result;\n      }\n      case \"array\": {\n        let array = value;\n        let len = array.length;\n        let result = new Array(len);\n        for (let i = 0; i < len; i++) {\n          result[i] = this.devaluateImpl(array[i], array, depth + 1);\n        }\n        return [result];\n      }\n      case \"bigint\":\n        return [\"bigint\", value.toString()];\n      case \"date\":\n        return [\"date\", value.getTime()];\n      case \"bytes\": {\n        let bytes = value;\n        if (bytes.toBase64) {\n          return [\"bytes\", bytes.toBase64({ omitPadding: true })];\n        } else {\n          return [\n            \"bytes\",\n            btoa(String.fromCharCode.apply(null, bytes).replace(/=*$/, \"\"))\n          ];\n        }\n      }\n      case \"error\": {\n        let e = value;\n        let rewritten = this.exporter.onSendError(e);\n        if (rewritten) {\n          e = rewritten;\n        }\n        let result = [\"error\", e.name, e.message];\n        if (rewritten && rewritten.stack) {\n          result.push(rewritten.stack);\n        }\n        return result;\n      }\n      case \"undefined\":\n        return [\"undefined\"];\n      case \"stub\":\n      case \"rpc-promise\": {\n        if (!this.source) {\n          throw new Error(\"Can't serialize RPC stubs in this context.\");\n        }\n        let { hook, pathIfPromise } = unwrapStubAndPath(value);\n        let importId = this.exporter.getImport(hook);\n        if (importId !== void 0) {\n          if (pathIfPromise) {\n            if (pathIfPromise.length > 0) {\n              return [\"pipeline\", importId, pathIfPromise];\n            } else {\n              return [\"pipeline\", importId];\n            }\n          } else {\n            return [\"import\", importId];\n          }\n        }\n        if (pathIfPromise) {\n          hook = hook.get(pathIfPromise);\n        } else {\n          hook = hook.dup();\n        }\n        return this.devaluateHook(pathIfPromise ? \"promise\" : \"export\", hook);\n      }\n      case \"function\":\n      case \"rpc-target\": {\n        if (!this.source) {\n          throw new Error(\"Can't serialize RPC stubs in this context.\");\n        }\n        let hook = this.source.getHookForRpcTarget(value, parent);\n        return this.devaluateHook(\"export\", hook);\n      }\n      case \"rpc-thenable\": {\n        if (!this.source) {\n          throw new Error(\"Can't serialize RPC stubs in this context.\");\n        }\n        let hook = this.source.getHookForRpcTarget(value, parent);\n        return this.devaluateHook(\"promise\", hook);\n      }\n      default:\n        throw new Error(\"unreachable\");\n    }\n  }\n  devaluateHook(type, hook) {\n    if (!this.exports) this.exports = [];\n    let exportId = type === \"promise\" ? this.exporter.exportPromise(hook) : this.exporter.exportStub(hook);\n    this.exports.push(exportId);\n    return [type, exportId];\n  }\n};\nvar NullImporter = class {\n  importStub(idx) {\n    throw new Error(\"Cannot deserialize RPC stubs without an RPC session.\");\n  }\n  importPromise(idx) {\n    throw new Error(\"Cannot deserialize RPC stubs without an RPC session.\");\n  }\n  getExport(idx) {\n    return void 0;\n  }\n};\nvar NULL_IMPORTER = new NullImporter();\nvar Evaluator = class _Evaluator {\n  constructor(importer) {\n    this.importer = importer;\n  }\n  stubs = [];\n  promises = [];\n  evaluate(value) {\n    let payload = RpcPayload.forEvaluate(this.stubs, this.promises);\n    try {\n      payload.value = this.evaluateImpl(value, payload, \"value\");\n      return payload;\n    } catch (err) {\n      payload.dispose();\n      throw err;\n    }\n  }\n  // Evaluate the value without destroying it.\n  evaluateCopy(value) {\n    return this.evaluate(structuredClone(value));\n  }\n  evaluateImpl(value, parent, property) {\n    if (value instanceof Array) {\n      if (value.length == 1 && value[0] instanceof Array) {\n        let result = value[0];\n        for (let i = 0; i < result.length; i++) {\n          result[i] = this.evaluateImpl(result[i], result, i);\n        }\n        return result;\n      } else switch (value[0]) {\n        case \"bigint\":\n          if (typeof value[1] == \"string\") {\n            return BigInt(value[1]);\n          }\n          break;\n        case \"date\":\n          if (typeof value[1] == \"number\") {\n            return new Date(value[1]);\n          }\n          break;\n        case \"bytes\": {\n          let b64 = Uint8Array;\n          if (typeof value[1] == \"string\") {\n            if (b64.fromBase64) {\n              return b64.fromBase64(value[1]);\n            } else {\n              let bs = atob(value[1]);\n              let len = bs.length;\n              let bytes = new Uint8Array(len);\n              for (let i = 0; i < len; i++) {\n                bytes[i] = bs.charCodeAt(i);\n              }\n              return bytes;\n            }\n          }\n          break;\n        }\n        case \"error\":\n          if (value.length >= 3 && typeof value[1] === \"string\" && typeof value[2] === \"string\") {\n            let cls = ERROR_TYPES[value[1]] || Error;\n            let result = new cls(value[2]);\n            if (typeof value[3] === \"string\") {\n              result.stack = value[3];\n            }\n            return result;\n          }\n          break;\n        case \"undefined\":\n          if (value.length === 1) {\n            return void 0;\n          }\n          break;\n        case \"import\":\n        case \"pipeline\": {\n          if (value.length < 2 || value.length > 4) {\n            break;\n          }\n          if (typeof value[1] != \"number\") {\n            break;\n          }\n          let hook = this.importer.getExport(value[1]);\n          if (!hook) {\n            throw new Error(`no such entry on exports table: ${value[1]}`);\n          }\n          let isPromise = value[0] == \"pipeline\";\n          let addStub = (hook2) => {\n            if (isPromise) {\n              let promise = new RpcPromise(hook2, []);\n              this.promises.push({ promise, parent, property });\n              return promise;\n            } else {\n              let stub = new RpcPromise(hook2, []);\n              this.stubs.push(stub);\n              return stub;\n            }\n          };\n          if (value.length == 2) {\n            if (isPromise) {\n              return addStub(hook.get([]));\n            } else {\n              return addStub(hook.dup());\n            }\n          }\n          let path = value[2];\n          if (!(path instanceof Array)) {\n            break;\n          }\n          if (!path.every(\n            (part) => {\n              return typeof part == \"string\" || typeof part == \"number\";\n            }\n          )) {\n            break;\n          }\n          if (value.length == 3) {\n            return addStub(hook.get(path));\n          }\n          let args = value[3];\n          if (!(args instanceof Array)) {\n            break;\n          }\n          let subEval = new _Evaluator(this.importer);\n          args = subEval.evaluate([args]);\n          return addStub(hook.call(path, args));\n        }\n        case \"remap\": {\n          if (value.length !== 5 || typeof value[1] !== \"number\" || !(value[2] instanceof Array) || !(value[3] instanceof Array) || !(value[4] instanceof Array)) {\n            break;\n          }\n          let hook = this.importer.getExport(value[1]);\n          if (!hook) {\n            throw new Error(`no such entry on exports table: ${value[1]}`);\n          }\n          let path = value[2];\n          if (!path.every(\n            (part) => {\n              return typeof part == \"string\" || typeof part == \"number\";\n            }\n          )) {\n            break;\n          }\n          let captures = value[3].map((cap) => {\n            if (!(cap instanceof Array) || cap.length !== 2 || cap[0] !== \"import\" && cap[0] !== \"export\" || typeof cap[1] !== \"number\") {\n              throw new TypeError(`unknown map capture: ${JSON.stringify(cap)}`);\n            }\n            if (cap[0] === \"export\") {\n              return this.importer.importStub(cap[1]);\n            } else {\n              let exp = this.importer.getExport(cap[1]);\n              if (!exp) {\n                throw new Error(`no such entry on exports table: ${cap[1]}`);\n              }\n              return exp.dup();\n            }\n          });\n          let instructions = value[4];\n          let resultHook = hook.map(path, captures, instructions);\n          let promise = new RpcPromise(resultHook, []);\n          this.promises.push({ promise, parent, property });\n          return promise;\n        }\n        case \"export\":\n        case \"promise\":\n          if (typeof value[1] == \"number\") {\n            if (value[0] == \"promise\") {\n              let hook = this.importer.importPromise(value[1]);\n              let promise = new RpcPromise(hook, []);\n              this.promises.push({ parent, property, promise });\n              return promise;\n            } else {\n              let hook = this.importer.importStub(value[1]);\n              let stub = new RpcStub(hook);\n              this.stubs.push(stub);\n              return stub;\n            }\n          }\n          break;\n      }\n      throw new TypeError(`unknown special value: ${JSON.stringify(value)}`);\n    } else if (value instanceof Object) {\n      let result = value;\n      for (let key in result) {\n        if (key in Object.prototype || key === \"toJSON\") {\n          this.evaluateImpl(result[key], result, key);\n          delete result[key];\n        } else {\n          result[key] = this.evaluateImpl(result[key], result, key);\n        }\n      }\n      return result;\n    } else {\n      return value;\n    }\n  }\n};\nvar ImportTableEntry = class {\n  constructor(session, importId, pulling) {\n    this.session = session;\n    this.importId = importId;\n    if (pulling) {\n      this.activePull = Promise.withResolvers();\n    }\n  }\n  localRefcount = 0;\n  remoteRefcount = 1;\n  activePull;\n  resolution;\n  // List of integer indexes into session.onBrokenCallbacks which are callbacks registered on\n  // this import. Initialized on first use (so `undefined` is the same as an empty list).\n  onBrokenRegistrations;\n  resolve(resolution) {\n    if (this.localRefcount == 0) {\n      resolution.dispose();\n      return;\n    }\n    this.resolution = resolution;\n    this.sendRelease();\n    if (this.onBrokenRegistrations) {\n      for (let i of this.onBrokenRegistrations) {\n        let callback = this.session.onBrokenCallbacks[i];\n        let endIndex = this.session.onBrokenCallbacks.length;\n        resolution.onBroken(callback);\n        if (this.session.onBrokenCallbacks[endIndex] === callback) {\n          delete this.session.onBrokenCallbacks[endIndex];\n        } else {\n          delete this.session.onBrokenCallbacks[i];\n        }\n      }\n      this.onBrokenRegistrations = void 0;\n    }\n    if (this.activePull) {\n      this.activePull.resolve();\n      this.activePull = void 0;\n    }\n  }\n  async awaitResolution() {\n    if (!this.activePull) {\n      this.session.sendPull(this.importId);\n      this.activePull = Promise.withResolvers();\n    }\n    await this.activePull.promise;\n    return this.resolution.pull();\n  }\n  dispose() {\n    if (this.resolution) {\n      this.resolution.dispose();\n    } else {\n      this.abort(new Error(\"RPC was canceled because the RpcPromise was disposed.\"));\n      this.sendRelease();\n    }\n  }\n  abort(error) {\n    if (!this.resolution) {\n      this.resolution = new ErrorStubHook(error);\n      if (this.activePull) {\n        this.activePull.reject(error);\n        this.activePull = void 0;\n      }\n      this.onBrokenRegistrations = void 0;\n    }\n  }\n  onBroken(callback) {\n    if (this.resolution) {\n      this.resolution.onBroken(callback);\n    } else {\n      let index = this.session.onBrokenCallbacks.length;\n      this.session.onBrokenCallbacks.push(callback);\n      if (!this.onBrokenRegistrations) this.onBrokenRegistrations = [];\n      this.onBrokenRegistrations.push(index);\n    }\n  }\n  sendRelease() {\n    if (this.remoteRefcount > 0) {\n      this.session.sendRelease(this.importId, this.remoteRefcount);\n      this.remoteRefcount = 0;\n    }\n  }\n};\nvar RpcImportHook = class _RpcImportHook extends StubHook {\n  // undefined when we're disposed\n  // `pulling` is true if we already expect that this import is going to be resolved later, and\n  // null if this import is not allowed to be pulled (i.e. it's a stub not a promise).\n  constructor(isPromise, entry) {\n    super();\n    this.isPromise = isPromise;\n    ++entry.localRefcount;\n    this.entry = entry;\n  }\n  entry;\n  collectPath(path) {\n    return this;\n  }\n  getEntry() {\n    if (this.entry) {\n      return this.entry;\n    } else {\n      throw new Error(\"This RpcImportHook was already disposed.\");\n    }\n  }\n  // -------------------------------------------------------------------------------------\n  // implements StubHook\n  call(path, args) {\n    let entry = this.getEntry();\n    if (entry.resolution) {\n      return entry.resolution.call(path, args);\n    } else {\n      return entry.session.sendCall(entry.importId, path, args);\n    }\n  }\n  map(path, captures, instructions) {\n    let entry;\n    try {\n      entry = this.getEntry();\n    } catch (err) {\n      for (let cap of captures) {\n        cap.dispose();\n      }\n      throw err;\n    }\n    if (entry.resolution) {\n      return entry.resolution.map(path, captures, instructions);\n    } else {\n      return entry.session.sendMap(entry.importId, path, captures, instructions);\n    }\n  }\n  get(path) {\n    let entry = this.getEntry();\n    if (entry.resolution) {\n      return entry.resolution.get(path);\n    } else {\n      return entry.session.sendCall(entry.importId, path);\n    }\n  }\n  dup() {\n    return new _RpcImportHook(false, this.getEntry());\n  }\n  pull() {\n    let entry = this.getEntry();\n    if (!this.isPromise) {\n      throw new Error(\"Can't pull this hook because it's not a promise hook.\");\n    }\n    if (entry.resolution) {\n      return entry.resolution.pull();\n    }\n    return entry.awaitResolution();\n  }\n  ignoreUnhandledRejections() {\n  }\n  dispose() {\n    let entry = this.entry;\n    this.entry = void 0;\n    if (entry) {\n      if (--entry.localRefcount === 0) {\n        entry.dispose();\n      }\n    }\n  }\n  onBroken(callback) {\n    if (this.entry) {\n      this.entry.onBroken(callback);\n    }\n  }\n};\nvar RpcMainHook = class extends RpcImportHook {\n  session;\n  constructor(entry) {\n    super(false, entry);\n    this.session = entry.session;\n  }\n  dispose() {\n    if (this.session) {\n      let session = this.session;\n      this.session = void 0;\n      session.shutdown();\n    }\n  }\n};\nvar RpcSessionImpl = class {\n  constructor(transport, mainHook, options) {\n    this.transport = transport;\n    this.options = options;\n    this.exports.push({ hook: mainHook, refcount: 1 });\n    this.imports.push(new ImportTableEntry(this, 0, false));\n    let rejectFunc;\n    let abortPromise = new Promise((resolve, reject) => {\n      rejectFunc = reject;\n    });\n    this.cancelReadLoop = rejectFunc;\n    this.readLoop(abortPromise).catch((err) => this.abort(err));\n  }\n  exports = [];\n  reverseExports = /* @__PURE__ */ new Map();\n  imports = [];\n  abortReason;\n  cancelReadLoop;\n  // We assign positive numbers to imports we initiate, and negative numbers to exports we\n  // initiate. So the next import ID is just `imports.length`, but the next export ID needs\n  // to be tracked explicitly.\n  nextExportId = -1;\n  // If set, call this when all incoming calls are complete.\n  onBatchDone;\n  // How many promises is our peer expecting us to resolve?\n  pullCount = 0;\n  // Sparse array of onBrokenCallback registrations. Items are strictly appended to the end but\n  // may be deleted from the middle (hence leaving the array sparse).\n  onBrokenCallbacks = [];\n  // Should only be called once immediately after construction.\n  getMainImport() {\n    return new RpcMainHook(this.imports[0]);\n  }\n  shutdown() {\n    this.abort(new Error(\"RPC session was shut down by disposing the main stub\"), false);\n  }\n  exportStub(hook) {\n    if (this.abortReason) throw this.abortReason;\n    let existingExportId = this.reverseExports.get(hook);\n    if (existingExportId !== void 0) {\n      ++this.exports[existingExportId].refcount;\n      return existingExportId;\n    } else {\n      let exportId = this.nextExportId--;\n      this.exports[exportId] = { hook, refcount: 1 };\n      this.reverseExports.set(hook, exportId);\n      return exportId;\n    }\n  }\n  exportPromise(hook) {\n    if (this.abortReason) throw this.abortReason;\n    let exportId = this.nextExportId--;\n    this.exports[exportId] = { hook, refcount: 1 };\n    this.reverseExports.set(hook, exportId);\n    this.ensureResolvingExport(exportId);\n    return exportId;\n  }\n  unexport(ids) {\n    for (let id of ids) {\n      this.releaseExport(id, 1);\n    }\n  }\n  releaseExport(exportId, refcount) {\n    let entry = this.exports[exportId];\n    if (!entry) {\n      throw new Error(`no such export ID: ${exportId}`);\n    }\n    if (entry.refcount < refcount) {\n      throw new Error(`refcount would go negative: ${entry.refcount} < ${refcount}`);\n    }\n    entry.refcount -= refcount;\n    if (entry.refcount === 0) {\n      delete this.exports[exportId];\n      this.reverseExports.delete(entry.hook);\n      entry.hook.dispose();\n    }\n  }\n  onSendError(error) {\n    if (this.options.onSendError) {\n      return this.options.onSendError(error);\n    }\n  }\n  ensureResolvingExport(exportId) {\n    let exp = this.exports[exportId];\n    if (!exp) {\n      throw new Error(`no such export ID: ${exportId}`);\n    }\n    if (!exp.pull) {\n      let resolve = async () => {\n        let hook = exp.hook;\n        for (; ; ) {\n          let payload = await hook.pull();\n          if (payload.value instanceof RpcStub) {\n            let { hook: inner, pathIfPromise } = unwrapStubAndPath(payload.value);\n            if (pathIfPromise && pathIfPromise.length == 0) {\n              if (this.getImport(hook) === void 0) {\n                hook = inner;\n                continue;\n              }\n            }\n          }\n          return payload;\n        }\n      };\n      ++this.pullCount;\n      exp.pull = resolve().then(\n        (payload) => {\n          let value = Devaluator.devaluate(payload.value, void 0, this, payload);\n          this.send([\"resolve\", exportId, value]);\n        },\n        (error) => {\n          this.send([\"reject\", exportId, Devaluator.devaluate(error, void 0, this)]);\n        }\n      ).catch(\n        (error) => {\n          try {\n            this.send([\"reject\", exportId, Devaluator.devaluate(error, void 0, this)]);\n          } catch (error2) {\n            this.abort(error2);\n          }\n        }\n      ).finally(() => {\n        if (--this.pullCount === 0) {\n          if (this.onBatchDone) {\n            this.onBatchDone.resolve();\n          }\n        }\n      });\n    }\n  }\n  getImport(hook) {\n    if (hook instanceof RpcImportHook && hook.entry && hook.entry.session === this) {\n      return hook.entry.importId;\n    } else {\n      return void 0;\n    }\n  }\n  importStub(idx) {\n    if (this.abortReason) throw this.abortReason;\n    let entry = this.imports[idx];\n    if (!entry) {\n      entry = new ImportTableEntry(this, idx, false);\n      this.imports[idx] = entry;\n    }\n    return new RpcImportHook(\n      /*isPromise=*/\n      false,\n      entry\n    );\n  }\n  importPromise(idx) {\n    if (this.abortReason) throw this.abortReason;\n    if (this.imports[idx]) {\n      return new ErrorStubHook(new Error(\n        \"Bug in RPC system: The peer sent a promise reusing an existing export ID.\"\n      ));\n    }\n    let entry = new ImportTableEntry(this, idx, true);\n    this.imports[idx] = entry;\n    return new RpcImportHook(\n      /*isPromise=*/\n      true,\n      entry\n    );\n  }\n  getExport(idx) {\n    return this.exports[idx]?.hook;\n  }\n  send(msg) {\n    if (this.abortReason !== void 0) {\n      return;\n    }\n    let msgText;\n    try {\n      msgText = JSON.stringify(msg);\n    } catch (err) {\n      try {\n        this.abort(err);\n      } catch (err2) {\n      }\n      throw err;\n    }\n    this.transport.send(msgText).catch((err) => this.abort(err, false));\n  }\n  sendCall(id, path, args) {\n    if (this.abortReason) throw this.abortReason;\n    let value = [\"pipeline\", id, path];\n    if (args) {\n      let devalue = Devaluator.devaluate(args.value, void 0, this, args);\n      value.push(devalue[0]);\n    }\n    this.send([\"push\", value]);\n    let entry = new ImportTableEntry(this, this.imports.length, false);\n    this.imports.push(entry);\n    return new RpcImportHook(\n      /*isPromise=*/\n      true,\n      entry\n    );\n  }\n  sendMap(id, path, captures, instructions) {\n    if (this.abortReason) {\n      for (let cap of captures) {\n        cap.dispose();\n      }\n      throw this.abortReason;\n    }\n    let devaluedCaptures = captures.map((hook) => {\n      let importId = this.getImport(hook);\n      if (importId !== void 0) {\n        return [\"import\", importId];\n      } else {\n        return [\"export\", this.exportStub(hook)];\n      }\n    });\n    let value = [\"remap\", id, path, devaluedCaptures, instructions];\n    this.send([\"push\", value]);\n    let entry = new ImportTableEntry(this, this.imports.length, false);\n    this.imports.push(entry);\n    return new RpcImportHook(\n      /*isPromise=*/\n      true,\n      entry\n    );\n  }\n  sendPull(id) {\n    if (this.abortReason) throw this.abortReason;\n    this.send([\"pull\", id]);\n  }\n  sendRelease(id, remoteRefcount) {\n    if (this.abortReason) return;\n    this.send([\"release\", id, remoteRefcount]);\n    delete this.imports[id];\n  }\n  abort(error, trySendAbortMessage = true) {\n    if (this.abortReason !== void 0) return;\n    this.cancelReadLoop(error);\n    if (trySendAbortMessage) {\n      try {\n        this.transport.send(JSON.stringify([\"abort\", Devaluator.devaluate(error, void 0, this)])).catch((err) => {\n        });\n      } catch (err) {\n      }\n    }\n    if (error === void 0) {\n      error = \"undefined\";\n    }\n    this.abortReason = error;\n    if (this.onBatchDone) {\n      this.onBatchDone.reject(error);\n    }\n    if (this.transport.abort) {\n      try {\n        this.transport.abort(error);\n      } catch (err) {\n        Promise.resolve(err);\n      }\n    }\n    for (let i in this.onBrokenCallbacks) {\n      try {\n        this.onBrokenCallbacks[i](error);\n      } catch (err) {\n        Promise.resolve(err);\n      }\n    }\n    for (let i in this.imports) {\n      this.imports[i].abort(error);\n    }\n    for (let i in this.exports) {\n      this.exports[i].hook.dispose();\n    }\n  }\n  async readLoop(abortPromise) {\n    while (!this.abortReason) {\n      let msg = JSON.parse(await Promise.race([this.transport.receive(), abortPromise]));\n      if (this.abortReason) break;\n      if (msg instanceof Array) {\n        switch (msg[0]) {\n          case \"push\":\n            if (msg.length > 1) {\n              let payload = new Evaluator(this).evaluate(msg[1]);\n              let hook = new PayloadStubHook(payload);\n              hook.ignoreUnhandledRejections();\n              this.exports.push({ hook, refcount: 1 });\n              continue;\n            }\n            break;\n          case \"pull\": {\n            let exportId = msg[1];\n            if (typeof exportId == \"number\") {\n              this.ensureResolvingExport(exportId);\n              continue;\n            }\n            break;\n          }\n          case \"resolve\":\n          // [\"resolve\", ExportId, Expression]\n          case \"reject\": {\n            let importId = msg[1];\n            if (typeof importId == \"number\" && msg.length > 2) {\n              let imp = this.imports[importId];\n              if (imp) {\n                if (msg[0] == \"resolve\") {\n                  imp.resolve(new PayloadStubHook(new Evaluator(this).evaluate(msg[2])));\n                } else {\n                  let payload = new Evaluator(this).evaluate(msg[2]);\n                  payload.dispose();\n                  imp.resolve(new ErrorStubHook(payload.value));\n                }\n              } else {\n                if (msg[0] == \"resolve\") {\n                  new Evaluator(this).evaluate(msg[2]).dispose();\n                }\n              }\n              continue;\n            }\n            break;\n          }\n          case \"release\": {\n            let exportId = msg[1];\n            let refcount = msg[2];\n            if (typeof exportId == \"number\" && typeof refcount == \"number\") {\n              this.releaseExport(exportId, refcount);\n              continue;\n            }\n            break;\n          }\n          case \"abort\": {\n            let payload = new Evaluator(this).evaluate(msg[1]);\n            payload.dispose();\n            this.abort(payload, false);\n            break;\n          }\n        }\n      }\n      throw new Error(`bad RPC message: ${JSON.stringify(msg)}`);\n    }\n  }\n  async drain() {\n    if (this.abortReason) {\n      throw this.abortReason;\n    }\n    if (this.pullCount > 0) {\n      let { promise, resolve, reject } = Promise.withResolvers();\n      this.onBatchDone = { resolve, reject };\n      await promise;\n    }\n  }\n  getStats() {\n    let result = { imports: 0, exports: 0 };\n    for (let i in this.imports) {\n      ++result.imports;\n    }\n    for (let i in this.exports) {\n      ++result.exports;\n    }\n    return result;\n  }\n};\nvar RpcSession = class {\n  #session;\n  #mainStub;\n  constructor(transport, localMain, options = {}) {\n    let mainHook;\n    if (localMain) {\n      mainHook = new PayloadStubHook(RpcPayload.fromAppReturn(localMain));\n    } else {\n      mainHook = new ErrorStubHook(new Error(\"This connection has no main object.\"));\n    }\n    this.#session = new RpcSessionImpl(transport, mainHook, options);\n    this.#mainStub = new RpcStub(this.#session.getMainImport());\n  }\n  getRemoteMain() {\n    return this.#mainStub;\n  }\n  getStats() {\n    return this.#session.getStats();\n  }\n  drain() {\n    return this.#session.drain();\n  }\n};\nfunction newWebSocketRpcSession(webSocket, localMain, options) {\n  if (typeof webSocket === \"string\") {\n    webSocket = new WebSocket(webSocket);\n  }\n  let transport = new WebSocketTransport(webSocket);\n  let rpc = new RpcSession(transport, localMain, options);\n  return rpc.getRemoteMain();\n}\nfunction newWorkersWebSocketRpcResponse(request, localMain, options) {\n  if (request.headers.get(\"Upgrade\")?.toLowerCase() !== \"websocket\") {\n    return new Response(\"This endpoint only accepts WebSocket requests.\", { status: 400 });\n  }\n  let pair = new WebSocketPair();\n  let server = pair[0];\n  server.accept();\n  newWebSocketRpcSession(server, localMain, options);\n  return new Response(null, {\n    status: 101,\n    webSocket: pair[1]\n  });\n}\nvar WebSocketTransport = class {\n  constructor(webSocket) {\n    this.#webSocket = webSocket;\n    if (webSocket.readyState === WebSocket.CONNECTING) {\n      this.#sendQueue = [];\n      webSocket.addEventListener(\"open\", (event) => {\n        try {\n          for (let message of this.#sendQueue) {\n            webSocket.send(message);\n          }\n        } catch (err) {\n          this.#receivedError(err);\n        }\n        this.#sendQueue = void 0;\n      });\n    }\n    webSocket.addEventListener(\"message\", (event) => {\n      if (this.#error) ;\n      else if (typeof event.data === \"string\") {\n        if (this.#receiveResolver) {\n          this.#receiveResolver(event.data);\n          this.#receiveResolver = void 0;\n          this.#receiveRejecter = void 0;\n        } else {\n          this.#receiveQueue.push(event.data);\n        }\n      } else {\n        this.#receivedError(new TypeError(\"Received non-string message from WebSocket.\"));\n      }\n    });\n    webSocket.addEventListener(\"close\", (event) => {\n      this.#receivedError(new Error(`Peer closed WebSocket: ${event.code} ${event.reason}`));\n    });\n    webSocket.addEventListener(\"error\", (event) => {\n      this.#receivedError(new Error(`WebSocket connection failed.`));\n    });\n  }\n  #webSocket;\n  #sendQueue;\n  // only if not opened yet\n  #receiveResolver;\n  #receiveRejecter;\n  #receiveQueue = [];\n  #error;\n  async send(message) {\n    if (this.#sendQueue === void 0) {\n      this.#webSocket.send(message);\n    } else {\n      this.#sendQueue.push(message);\n    }\n  }\n  async receive() {\n    if (this.#receiveQueue.length > 0) {\n      return this.#receiveQueue.shift();\n    } else if (this.#error) {\n      throw this.#error;\n    } else {\n      return new Promise((resolve, reject) => {\n        this.#receiveResolver = resolve;\n        this.#receiveRejecter = reject;\n      });\n    }\n  }\n  abort(reason) {\n    let message;\n    if (reason instanceof Error) {\n      message = reason.message;\n    } else {\n      message = `${reason}`;\n    }\n    this.#webSocket.close(3e3, message);\n    if (!this.#error) {\n      this.#error = reason;\n    }\n  }\n  #receivedError(reason) {\n    if (!this.#error) {\n      this.#error = reason;\n      if (this.#receiveRejecter) {\n        this.#receiveRejecter(reason);\n        this.#receiveResolver = void 0;\n        this.#receiveRejecter = void 0;\n      }\n    }\n  }\n};\nvar BatchServerTransport = class {\n  constructor(batch) {\n    this.#batchToReceive = batch;\n  }\n  #batchToSend = [];\n  #batchToReceive;\n  #allReceived = Promise.withResolvers();\n  async send(message) {\n    this.#batchToSend.push(message);\n  }\n  async receive() {\n    let msg = this.#batchToReceive.shift();\n    if (msg !== void 0) {\n      return msg;\n    } else {\n      this.#allReceived.resolve();\n      return new Promise((r) => {\n      });\n    }\n  }\n  abort(reason) {\n    this.#allReceived.reject(reason);\n  }\n  whenAllReceived() {\n    return this.#allReceived.promise;\n  }\n  getResponseBody() {\n    return this.#batchToSend.join(\"\\n\");\n  }\n};\nasync function newHttpBatchRpcResponse(request, localMain, options) {\n  if (request.method !== \"POST\") {\n    return new Response(\"This endpoint only accepts POST requests.\", { status: 405 });\n  }\n  let body = await request.text();\n  let batch = body === \"\" ? [] : body.split(\"\\n\");\n  let transport = new BatchServerTransport(batch);\n  let rpc = new RpcSession(transport, localMain, options);\n  await transport.whenAllReceived();\n  await rpc.drain();\n  return new Response(transport.getResponseBody());\n}\nvar currentMapBuilder;\nvar MapBuilder = class {\n  context;\n  captureMap = /* @__PURE__ */ new Map();\n  instructions = [];\n  constructor(subject, path) {\n    if (currentMapBuilder) {\n      this.context = {\n        parent: currentMapBuilder,\n        captures: [],\n        subject: currentMapBuilder.capture(subject),\n        path\n      };\n    } else {\n      this.context = {\n        parent: void 0,\n        captures: [],\n        subject,\n        path\n      };\n    }\n    currentMapBuilder = this;\n  }\n  unregister() {\n    currentMapBuilder = this.context.parent;\n  }\n  makeInput() {\n    return new MapVariableHook(this, 0);\n  }\n  makeOutput(result) {\n    let devalued;\n    try {\n      devalued = Devaluator.devaluate(result.value, void 0, this, result);\n    } finally {\n      result.dispose();\n    }\n    this.instructions.push(devalued);\n    if (this.context.parent) {\n      this.context.parent.instructions.push(\n        [\n          \"remap\",\n          this.context.subject,\n          this.context.path,\n          this.context.captures.map((cap) => [\"import\", cap]),\n          this.instructions\n        ]\n      );\n      return new MapVariableHook(this.context.parent, this.context.parent.instructions.length);\n    } else {\n      return this.context.subject.map(this.context.path, this.context.captures, this.instructions);\n    }\n  }\n  pushCall(hook, path, params) {\n    let devalued = Devaluator.devaluate(params.value, void 0, this, params);\n    devalued = devalued[0];\n    let subject = this.capture(hook.dup());\n    this.instructions.push([\"pipeline\", subject, path, devalued]);\n    return new MapVariableHook(this, this.instructions.length);\n  }\n  pushGet(hook, path) {\n    let subject = this.capture(hook.dup());\n    this.instructions.push([\"pipeline\", subject, path]);\n    return new MapVariableHook(this, this.instructions.length);\n  }\n  capture(hook) {\n    if (hook instanceof MapVariableHook && hook.mapper === this) {\n      return hook.idx;\n    }\n    let result = this.captureMap.get(hook);\n    if (result === void 0) {\n      if (this.context.parent) {\n        let parentIdx = this.context.parent.capture(hook);\n        this.context.captures.push(parentIdx);\n      } else {\n        this.context.captures.push(hook);\n      }\n      result = -this.context.captures.length;\n      this.captureMap.set(hook, result);\n    }\n    return result;\n  }\n  // ---------------------------------------------------------------------------\n  // implements Exporter\n  exportStub(hook) {\n    throw new Error(\n      \"Can't construct an RpcTarget or RPC callback inside a mapper function. Try creating a new RpcStub outside the callback first, then using it inside the callback.\"\n    );\n  }\n  exportPromise(hook) {\n    return this.exportStub(hook);\n  }\n  getImport(hook) {\n    return this.capture(hook);\n  }\n  unexport(ids) {\n  }\n  onSendError(error) {\n  }\n};\nmapImpl.sendMap = (hook, path, func) => {\n  let builder = new MapBuilder(hook, path);\n  let result;\n  try {\n    result = RpcPayload.fromAppReturn(withCallInterceptor(builder.pushCall.bind(builder), () => {\n      return func(new RpcPromise(builder.makeInput(), []));\n    }));\n  } finally {\n    builder.unregister();\n  }\n  if (result instanceof Promise) {\n    result.catch((err) => {\n    });\n    throw new Error(\"RPC map() callbacks cannot be async.\");\n  }\n  return new RpcPromise(builder.makeOutput(result), []);\n};\nfunction throwMapperBuilderUseError() {\n  throw new Error(\n    \"Attempted to use an abstract placeholder from a mapper function. Please make sure your map function has no side effects.\"\n  );\n}\nvar MapVariableHook = class extends StubHook {\n  constructor(mapper, idx) {\n    super();\n    this.mapper = mapper;\n    this.idx = idx;\n  }\n  // We don't have anything we actually need to dispose, so dup() can just return the same hook.\n  dup() {\n    return this;\n  }\n  dispose() {\n  }\n  get(path) {\n    if (path.length == 0) {\n      return this;\n    } else if (currentMapBuilder) {\n      return currentMapBuilder.pushGet(this, path);\n    } else {\n      throwMapperBuilderUseError();\n    }\n  }\n  // Other methods should never be called.\n  call(path, args) {\n    throwMapperBuilderUseError();\n  }\n  map(path, captures, instructions) {\n    throwMapperBuilderUseError();\n  }\n  pull() {\n    throwMapperBuilderUseError();\n  }\n  ignoreUnhandledRejections() {\n  }\n  onBroken(callback) {\n    throwMapperBuilderUseError();\n  }\n};\nvar MapApplicator = class {\n  constructor(captures, input) {\n    this.captures = captures;\n    this.variables = [input];\n  }\n  variables;\n  dispose() {\n    for (let variable of this.variables) {\n      variable.dispose();\n    }\n  }\n  apply(instructions) {\n    try {\n      if (instructions.length < 1) {\n        throw new Error(\"Invalid empty mapper function.\");\n      }\n      for (let instruction of instructions.slice(0, -1)) {\n        let payload = new Evaluator(this).evaluateCopy(instruction);\n        if (payload.value instanceof RpcStub) {\n          let hook = unwrapStubNoProperties(payload.value);\n          if (hook) {\n            this.variables.push(hook);\n            continue;\n          }\n        }\n        this.variables.push(new PayloadStubHook(payload));\n      }\n      return new Evaluator(this).evaluateCopy(instructions[instructions.length - 1]);\n    } finally {\n      for (let variable of this.variables) {\n        variable.dispose();\n      }\n    }\n  }\n  importStub(idx) {\n    throw new Error(\"A mapper function cannot refer to exports.\");\n  }\n  importPromise(idx) {\n    return this.importStub(idx);\n  }\n  getExport(idx) {\n    if (idx < 0) {\n      return this.captures[-idx - 1];\n    } else {\n      return this.variables[idx];\n    }\n  }\n};\nfunction applyMapToElement(input, parent, owner, captures, instructions) {\n  let inputHook = new PayloadStubHook(RpcPayload.deepCopyFrom(input, parent, owner));\n  let mapper = new MapApplicator(captures, inputHook);\n  try {\n    return mapper.apply(instructions);\n  } finally {\n    mapper.dispose();\n  }\n}\nmapImpl.applyMap = (input, parent, owner, captures, instructions) => {\n  try {\n    let result;\n    if (input instanceof RpcPromise) {\n      throw new Error(\"applyMap() can't be called on RpcPromise\");\n    } else if (input instanceof Array) {\n      let payloads = [];\n      try {\n        for (let elem of input) {\n          payloads.push(applyMapToElement(elem, input, owner, captures, instructions));\n        }\n      } catch (err) {\n        for (let payload of payloads) {\n          payload.dispose();\n        }\n        throw err;\n      }\n      result = RpcPayload.fromArray(payloads);\n    } else if (input === null || input === void 0) {\n      result = RpcPayload.fromAppReturn(input);\n    } else {\n      result = applyMapToElement(input, parent, owner, captures, instructions);\n    }\n    return new PayloadStubHook(result);\n  } finally {\n    for (let cap of captures) {\n      cap.dispose();\n    }\n  }\n};\nasync function newWorkersRpcResponse(request, localMain) {\n  if (request.method === \"POST\") {\n    let response = await newHttpBatchRpcResponse(request, localMain);\n    response.headers.set(\"Access-Control-Allow-Origin\", \"*\");\n    return response;\n  } else if (request.headers.get(\"Upgrade\")?.toLowerCase() === \"websocket\") {\n    return newWorkersWebSocketRpcResponse(request, localMain);\n  } else {\n    return new Response(\"This endpoint only accepts POST or WebSocket requests.\", { status: 400 });\n  }\n}\n\n// templates/remoteBindings/ProxyServerWorker.ts\nimport { EmailMessage } from \"cloudflare:email\";\nvar BindingNotFoundError = class extends Error {\n  constructor(name) {\n    super(`Binding ${name ? `\"${name}\"` : \"\"} not found`);\n  }\n};\nfunction getExposedJSRPCBinding(request, env) {\n  const url = new URL(request.url);\n  const bindingName = url.searchParams.get(\"MF-Binding\");\n  if (!bindingName) {\n    throw new BindingNotFoundError();\n  }\n  const targetBinding = env[bindingName];\n  if (!targetBinding) {\n    throw new BindingNotFoundError(bindingName);\n  }\n  if (targetBinding.constructor.name === \"SendEmail\") {\n    return {\n      async send(e) {\n        const message = new EmailMessage(e.from, e.to, e[\"EmailMessage::raw\"]);\n        return targetBinding.send(message);\n      }\n    };\n  }\n  if (url.searchParams.has(\"MF-Dispatch-Namespace-Options\")) {\n    const { name, args, options } = JSON.parse(\n      url.searchParams.get(\"MF-Dispatch-Namespace-Options\")\n    );\n    return targetBinding.get(name, args, options);\n  }\n  return targetBinding;\n}\nfunction getExposedFetcher(request, env) {\n  const bindingName = request.headers.get(\"MF-Binding\");\n  if (!bindingName) {\n    throw new BindingNotFoundError();\n  }\n  const targetBinding = env[bindingName];\n  if (!targetBinding) {\n    throw new BindingNotFoundError(bindingName);\n  }\n  const dispatchNamespaceOptions = request.headers.get(\n    \"MF-Dispatch-Namespace-Options\"\n  );\n  if (dispatchNamespaceOptions) {\n    const { name, args, options } = JSON.parse(dispatchNamespaceOptions);\n    return targetBinding.get(name, args, options);\n  }\n  return targetBinding;\n}\nfunction isJSRPCBinding(request) {\n  const url = new URL(request.url);\n  return request.headers.has(\"Upgrade\") && url.searchParams.has(\"MF-Binding\");\n}\nvar ProxyServerWorker_default = {\n  async fetch(request, env) {\n    try {\n      if (isJSRPCBinding(request)) {\n        return newWorkersRpcResponse(\n          request,\n          getExposedJSRPCBinding(request, env)\n        );\n      } else {\n        const fetcher = getExposedFetcher(request, env);\n        const originalHeaders = new Headers();\n        for (const [name, value] of request.headers) {\n          if (name.startsWith(\"mf-header-\")) {\n            originalHeaders.set(name.slice(\"mf-header-\".length), value);\n          } else if (name === \"upgrade\") {\n            originalHeaders.set(name, value);\n          }\n        }\n        return fetcher.fetch(\n          request.headers.get(\"MF-URL\") ?? \"http://example.com\",\n          new Request(request, {\n            redirect: \"manual\",\n            headers: originalHeaders\n          })\n        );\n      }\n    } catch (e) {\n      if (e instanceof BindingNotFoundError) {\n        return new Response(e.message, { status: 400 });\n      }\n      return new Response(e.message, { status: 500 });\n    }\n  }\n};\nexport {\n  ProxyServerWorker_default as default\n};\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"/home/yanggf/.nvm/versions/node/v23.11.1/lib/node_modules/wrangler/wrangler-dist/ProxyServerWorker.js\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"/home/yanggf/.nvm/versions/node/v23.11.1/lib/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts\";\n\n\t\t\t\texport * from \"/home/yanggf/.nvm/versions/node/v23.11.1/lib/node_modules/wrangler/wrangler-dist/ProxyServerWorker.js\";\n\t\t\t\tconst MIDDLEWARE_TEST_INJECT = \"__INJECT_FOR_TESTING_WRANGLER_MIDDLEWARE__\";\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"/home/yanggf/a/cct/.wrangler/tmp/bundle-qpqDPe/middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"/home/yanggf/.nvm/versions/node/v23.11.1/lib/node_modules/wrangler/templates/middleware/common.ts\";\nimport type { WorkerEntrypointConstructor } from \"/home/yanggf/a/cct/.wrangler/tmp/bundle-qpqDPe/middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"/home/yanggf/a/cct/.wrangler/tmp/bundle-qpqDPe/middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": "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",
  "names": []
}
